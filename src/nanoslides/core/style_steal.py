"""Gemini-powered style extraction helpers."""

from __future__ import annotations

import json
import mimetypes
from dataclasses import dataclass
from enum import Enum
from pathlib import Path
from typing import Any

from google import genai
from google.genai import types


class StyleStealSourceKind(str, Enum):
    """Supported style-steal source kinds."""

    IMAGE = "image"


@dataclass(frozen=True)
class StyleStealSource:
    """Normalized style-steal source payload."""

    kind: StyleStealSourceKind
    path: Path
    mime_type: str
    bytes_data: bytes


@dataclass(frozen=True)
class StyleStealSuggestion:
    """Structured style suggestion generated by Gemini 3 Pro."""

    base_prompt: str
    negative_prompt: str
    reference_comments: list[str]
    use_as_base_reference: bool
    base_reference_reason: str


class GeminiStyleStealAnalyzer:
    """Analyze a source asset and infer reusable slide style instructions."""

    def __init__(self, *, api_key: str, timeout_seconds: float = 120.0) -> None:
        if timeout_seconds <= 0:
            raise ValueError("timeout_seconds must be greater than zero.")
        self._client = genai.Client(
            api_key=api_key,
            http_options=types.HttpOptions(
                api_version="v1alpha",
                timeout=timeout_seconds,
                retry_options=types.HttpRetryOptions(attempts=2),
            ),
        )

    def analyze(self, source: StyleStealSource) -> StyleStealSuggestion:
        if source.kind != StyleStealSourceKind.IMAGE:
            raise ValueError(f"Unsupported style-steal source kind: {source.kind}")

        response = self._client.models.generate_content(
            model="gemini-3-pro-preview",
            contents=[
                _STYLE_STEAL_PROMPT,
                types.Part.from_bytes(data=source.bytes_data, mime_type=source.mime_type),
            ],
            config=types.GenerateContentConfig(
                temperature=1.0,
                response_mime_type="application/json",
            ),
        )
        payload = _parse_json_response(response)

        base_prompt = str(payload.get("base_prompt", "")).strip()
        negative_prompt = str(payload.get("negative_prompt", "")).strip()
        use_as_base_reference = bool(payload.get("use_as_base_reference", False))
        base_reference_reason = str(payload.get("base_reference_reason", "")).strip()
        reference_comments = _normalize_comments(payload.get("reference_comments", []))

        if not base_prompt:
            raise RuntimeError("Style analysis returned an empty base_prompt.")
        if not base_reference_reason:
            raise RuntimeError(
                "Style analysis returned no explanation for base-reference decision."
            )

        return StyleStealSuggestion(
            base_prompt=base_prompt,
            negative_prompt=negative_prompt,
            reference_comments=reference_comments,
            use_as_base_reference=use_as_base_reference,
            base_reference_reason=base_reference_reason,
        )


def load_style_steal_source(path: Path) -> StyleStealSource:
    """Load and validate a style-steal source file."""
    source_path = path.expanduser().resolve()
    if not source_path.exists() or not source_path.is_file():
        raise ValueError(f"Style source file not found: {source_path}")

    mime_type = _guess_mime_type(source_path)
    kind = _detect_source_kind(mime_type)
    if kind is None:
        raise ValueError(
            "Unsupported style source type. Use an image file for now "
            "(future PDF/PPTX support planned)."
        )

    return StyleStealSource(
        kind=kind,
        path=source_path,
        mime_type=mime_type,
        bytes_data=source_path.read_bytes(),
    )


def _guess_mime_type(path: Path) -> str:
    mime_type, _ = mimetypes.guess_type(str(path))
    if not mime_type:
        raise ValueError(f"Unable to infer MIME type for style source: {path}")
    return mime_type


def _detect_source_kind(mime_type: str) -> StyleStealSourceKind | None:
    if mime_type.startswith("image/"):
        return StyleStealSourceKind.IMAGE
    return None


def _normalize_comments(raw_comments: Any) -> list[str]:
    if not isinstance(raw_comments, list):
        return []
    normalized: list[str] = []
    for raw_comment in raw_comments:
        comment = str(raw_comment).strip()
        if comment:
            normalized.append(comment)
    return normalized


def _parse_json_response(response: Any) -> dict[str, Any]:
    raw_text = getattr(response, "text", None)
    if not raw_text:
        raw_text = "\n".join(_response_text_parts(response))
    if not raw_text:
        raise RuntimeError("Style analysis returned no text output.")

    cleaned = raw_text.strip()
    if cleaned.startswith("```"):
        cleaned = cleaned.strip("`")
        if cleaned.startswith("json"):
            cleaned = cleaned[len("json") :].strip()
    try:
        payload = json.loads(cleaned)
    except json.JSONDecodeError as exc:
        raise RuntimeError(f"Style analysis returned invalid JSON: {exc}") from exc
    if not isinstance(payload, dict):
        raise RuntimeError("Style analysis JSON payload must be an object.")
    return payload


def _response_text_parts(response: Any) -> list[str]:
    text_parts: list[str] = []
    candidates = getattr(response, "candidates", None) or []
    for candidate in candidates:
        content = getattr(candidate, "content", None)
        parts = getattr(content, "parts", None) or []
        for part in parts:
            text = getattr(part, "text", None)
            if text:
                text_parts.append(str(text))
    return text_parts


_STYLE_STEAL_PROMPT = """
You are extracting a reusable visual style for AI-generated slides.

Analyze the source and return ONLY strict JSON with this schema:
{
  "base_prompt": string,
  "negative_prompt": string,
  "reference_comments": string[],
  "use_as_base_reference": boolean,
  "base_reference_reason": string
}

Rules:
- base_prompt must describe reusable visual style (color palette, typography feel, composition tendencies, texture, tone) and avoid content-specific details.
- negative_prompt should list what to avoid so future slides stay clean and consistent.
- reference_comments should be short actionable notes about the style.
- Decide use_as_base_reference:
  - true when the source is a broadly reusable style anchor that improves consistency.
  - false when the source has a very specific layout/composition that would overconstrain generations.
- base_reference_reason must explain the decision in one concise sentence.
- Never include markdown or extra keys.
""".strip()
